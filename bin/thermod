#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""Thermod daemon.

Copyright (C) 2018 Simone Rossetto <simros85@gmail.com>

This file is part of Thermod.

Thermod is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Thermod is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Thermod.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import sys
import logging
import argparse
import signal
import asyncio
import time

from logging.handlers import SysLogHandler, SMTPHandler
from jsonschema import ValidationError
from async_timeout import timeout

from thermod import common, config
from thermod.common import ScriptError, LogStyleAdapter, ThermodStatus
from thermod.thermometer import ScriptThermometer, ThermometerError, \
    PiAnalogZeroThermometer, SimilarityCheckerThermometerDecorator, \
    AveragingTaskThermometerDecorator
from thermod.heating import ScriptHeating, HeatingError, PiPinsRelayHeating
from thermod.timetable import TimeTable, JsonValueError
from thermod.socket import ControlSocket
from thermod.version import __version__ as PROGRAM_VERSION

__date__ = '2015-09-08'
__updated__ = '2018-05-12'

# TODO documentare return code
# TODO rivedere documentazione e provare a generarla con con doxygen (doxypy oppure doxypypy)
# TODO capire come fare ad eseguire i test alla creazione del pacchetto deb
# TODO aggiungere ai sorgenti i file della scatolina
# TODO rivedere test del socket che con il nuovo python e/o aiohttp non funzionano

# TODO usare asyncio.create_subprocess_exec() in ScriptThermometer e ScriptHeating
# per eseguire in modo asincrono le chiamate agli script esterne

# TODO [Roadmap 1.0.1] rivedere import dei moduli per velocizzare il caricamento
# TODO [Roadmap 1.0.1] inserire controllo su variazioni repentine di temperatura (ONGOING)
# TODO [Roadmap 1.0.1] scrivere test per PiAnalogZeroThermometer e per i Decorator

# TODO [Roadmap 1.1.0] fare client testuale
# TODO [Roadmap 1.1.0] creare manpage per questo file e per il client testuale
# TODO [Roadmap 1.1.0] scrivere Scheduler
# TODO [Roadmap 1.1.0] forse, impostare un timeout quando tramite pulsante si mette su "ON"
# TODO [Roadmap 1.1.0] modificare client web per permettere lo switch verso lo
# stato "ON" impostando però un timeout

# TODO [Roadmap 1.2.0] scrivere NetThermometer
# TODO [Roadmap 1.2.0] scrivere Pi1WireThermometer
# TODO [Roadmap 1.2.0] spostare l'averaging-task fuori dalla classe (ONGOING)
# PiAnalogZeroThermometer, così da poterlo usare in qualasiasi termometro:
# potrebbe essere fatto con un Decorator.

# TODO [Roadmap 2.0.0] chiamare le temperature t0, t1 e t2
# TODO [Roadmap 2.0.0] aggiungere modalità di funzionamento estivo
# TODO [Roadmap 2.0.0] modificare client web per permettere di impostare tre livelli di
# temperatura per ogni singolo quarto d'ora

script_path = os.path.dirname(os.path.realpath(__file__))
main_return_code = common.RET_CODE_OK


# parsing input arguments
parser = argparse.ArgumentParser(description='Thermod: programmable thermostat daemon for smart-heating automation')
parser.add_argument('-v', '--version', action='version', version='%(prog)s {}'.format(PROGRAM_VERSION))
parser.add_argument('-C', '--config', action='store', default=None, help='read configuration from CONFIG file (full path)')
parser.add_argument('-L', '--log', action='store', default=None, help='write log messages to LOG file (full path)')
parser.add_argument('-D', '--debug', action='store_true', help='enable debug messages')
parser.add_argument('-d', '--daemon', action='store_true', help='write log messages to syslog and honor `enabled` setting in config file (can be used when started from systemd)')
args = parser.parse_args()


# setting up logging system
logger = LogStyleAdapter(logging.getLogger(common.LOGGER_BASE_NAME))
logger.setLevel(logging.INFO)

if args.debug:
    logger.setLevel(logging.DEBUG)

if args.daemon:
    syslog = SysLogHandler(address='/dev/log', facility=SysLogHandler.LOG_DAEMON)
    syslog.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG_SYSLOG,
                                          style=common.LOGGER_FMT_STYLE))
    logger.addHandler(syslog)

else:
    console = logging.StreamHandler(sys.stdout)
    console.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG,
                                           datefmt=common.LOGGER_FMT_TIME,
                                           style=common.LOGGER_FMT_STYLE))
    logger.addHandler(console)

if args.log:
    try:
        logfile = logging.FileHandler(args.log, mode='a')
    
    except PermissionError as pe:
        logger.warning('cannot write log to `{}`: {}', args.log, pe)
        logger.info('the daemon will start without logfile')
    
    else:
        logfile.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG,
                                               datefmt=common.LOGGER_FMT_DATETIME,
                                               style=common.LOGGER_FMT_STYLE))
        logger.addHandler(logfile)
    
        if args.daemon:
            # When a custom log file is configured and the deamon in started
            # in background, only warnings and errors are printed to syslog.
            syslog.setLevel(logging.WARNING)
        
        logger.debug('logging to file {}', args.log)

if args.daemon:
    logger.debug('logging to syslog (daemon facility)')
else:
    logger.debug('logging to console')


# reading configuration files
(cfg, main_return_code) = config.read_config_file(args.config)

if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)
    exit(main_return_code)


# parsing main settings
settings = config.parse_main_settings(cfg)
debug = settings.debug or args.debug

if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)
    exit(main_return_code)


# if executed in foreground we ignore the 'enabled' setting in config file
enabled = settings.enabled or (not args.daemon)

# if disabled we exit immediately
if not enabled:
    logger.info('daemon disabled in configuration file, exiting...')
    exit(common.RET_CODE_DAEMON_DISABLED)


# if mail server is present in configuration file, a new SMTPHandler is created
if settings.email['server']:
    logger.debug('configuring e-mail alerts to: {}', settings.email['recipients'])
    
    maillog = SMTPHandler(settings.email['server'],
                          settings.email['sender'],
                          settings.email['recipients'],
                          settings.email['subject'],
                          settings.email['credentials'])
    
    maillog.setFormatter(logging.Formatter(fmt=common.LOGGER_FMT_MSG_MAILLOG,
                                           datefmt=common.LOGGER_FMT_DATETIME,
                                           style=common.LOGGER_FMT_STYLE))
    
    maillog.setLevel(logging.WARNING)
    logger.addHandler(maillog)


# setting again the debug level if requested in configuration file
if debug:
    logger.setLevel(logging.DEBUG)


# initializing base objects
try:
    logger.debug('creating base objects')
    
    # the main event loop
    main_loop = asyncio.get_event_loop()
    
    # the main lock
    masterlock = asyncio.Condition(loop=main_loop)
    
    # the timetable
    timetable = TimeTable(settings.tt_file, settings.mode)
    
    # the heating
    if settings.heating['manager'] == 'scripts':
        heating = ScriptHeating(settings.heating['on'],
                                settings.heating['off'],
                                settings.heating['status'],
                                debug)
    
    elif settings.heating['manager'] == 'PiPinsRelay':
        heating = PiPinsRelayHeating(settings.heating['pins'],
                                     settings.heating['level'])
    
    # An `elif` can be added with additional specific heating classes
    # once they will be created.
    else:
        # The execution should not arrive here because the settings are
        # already checked inside common.parse_main_settings() function.
        raise RuntimeError('invalid heating configuration')
    
    # the thermometer
    if settings.thermometer['script'][0] == '/':  # a full path starts with /
        thermometer = ScriptThermometer(settings.thermometer['script'],
                                        debug,
                                        settings.thermometer['scale'],
                                        settings.thermometer['t_ref'],
                                        settings.thermometer['t_raw'])
        
    elif settings.thermometer['script'] == 'PiAnalogZero':
        thermometer = PiAnalogZeroThermometer(settings.thermometer['channels'],
                                              settings.thermometer['scale'],
                                              settings.thermometer['t_ref'],
                                              settings.thermometer['t_raw'],
                                              settings.thermometer['stddev'])
    
    # An `elif` can be added with additional specific thermometer classes
    # once they will be created.
    else:
        # The execution should not arrive here because the settings are
        # already checked inside common.parse_main_settings() function.
        raise RuntimeError('invalid thermometer configuration')
    
    if settings.thermometer['similcheck']:
        # enable similarity decorator
        thermometer = SimilarityCheckerThermometerDecorator(
                            thermometer,
                            settings.thermometer['simillen'],
                            settings.thermometer['simildelta'])
    
    if settings.thermometer['avgtask']:
        # enable averaging task decorator
        thermometer = AveragingTaskThermometerDecorator(
                            thermometer,
                            settings.thermometer['avgint'],
                            settings.thermometer['avgtime'],
                            settings.thermometer['avgskip'],
                            main_loop)
    
    # the control socket
    # TODO controllare gli errori possibili alla creazione del socket asyncrono
    socket = ControlSocket(timetable, heating, thermometer,
                           settings.host, settings.port,
                           masterlock, main_loop)

except ScriptError as se:
    main_return_code = common.RET_CODE_SCRIPT_INIT_ERR
    logger.critical('error accessing the script `{}`: {}', se.script, se)

except FileNotFoundError as fnfe:
    main_return_code = common.RET_CODE_TT_NOT_FOUND
    logger.critical('cannot find timetable file `{}`', settings.tt_file)

except PermissionError as pe:
    main_return_code = common.RET_CODE_TT_READ_ERR
    logger.critical('cannot read timetable file `{}`', settings.tt_file)

except OSError as oe:
    main_return_code = common.RET_CODE_OS_INIT_ERR
    logger.critical('error during creation of base objects: {}', oe)

except ValueError as ve:
    main_return_code = common.RET_CODE_TT_INVALID_SYNTAX
    logger.critical('timetable file is not in JSON format or has syntax errors: {}', ve)

except ValidationError as jsve:
    main_return_code = common.RET_CODE_TT_INVALID_CONTENT
    logger.critical('invalid element {} in timetable file: {}', list(jsve.path), jsve.message)

except HeatingError as he:
    main_return_code = common.RET_CODE_HW_INIT_ERR
    logger.critical('cannot initialize heating: {} ({})', he,
                    (he.suberror if he.suberror else 'no other information'))

except ThermometerError as te:
    main_return_code = common.RET_CODE_HW_INIT_ERR
    logger.critical('cannot initialize thermometer: {} ({})', te,
                    (te.suberror if te.suberror else 'no other information'))

except RuntimeError as re:
    main_return_code = common.RET_CODE_CFG_FILE_UNKNOWN_ERR
    logger.critical('error during creation of base objects: {}', re)

except Exception as e:
    main_return_code = common.RET_CODE_INIT_ERR
    logger.critical('error during daemon initialization: {}', e, exc_info=True)

except KeyboardInterrupt:
    main_return_code = common.RET_CODE_KEYB_INTERRUPT

else:
    main_return_code = common.RET_CODE_OK
    logger.debug('base objects created')
    
finally:
    if main_return_code != common.RET_CODE_OK:
        logger.info('closing daemon with return code {}', main_return_code)
        exit(main_return_code)


def shutdown(exitcode=common.RET_CODE_OK):
    """Shutdown the daemon."""
    
    global enabled, main_return_code
    logger.info('shutdown requested')
    
    async def stop_cycle():
        global enabled
        thermometer.close()
        async with masterlock:
            enabled = False
            masterlock.notify_all()
    
    if main_loop.is_running():
        main_loop.create_task(stop_cycle())
    else:
        main_loop.run_until_complete(stop_cycle())

    # setting the global return code
    main_return_code = exitcode


def reload_timetable():
    """Reaload timetable json file."""
    
    logger.info('timetable reload requested')
    
    async def reload():
        async with masterlock:
            try:
                timetable.reload()
                masterlock.notify_all()
            
            except OSError as oe:
                logger.warning('cannot reload timetable file `{}`, '
                               'old settings remain unchanged: {}',
                               timetable.filepath, oe)
            
            except ValidationError as jsve:
                logger.warning('cannot reload settings, timetable file '
                               'contains invalid data in element {}: {}',
                               list(jsve.path), jsve.message)
            
            except ValueError as ve:
                logger.warning('cannot reload settings, timetable file '
                               'contains invalid data: {}', ve)
            
            except Exception as e:
                logger.warning('error while reloading timetable, old '
                               'settings remain unchanged: {}', e)
    
    main_loop.create_task(reload())


def toggle_debug_messages():
    """Enable or disable debug messages at runtime."""
    
    if logger.level != logging.DEBUG:
        logger.setLevel(logging.DEBUG)
        logger.info('debug messages enabled')
    else:
        logger.setLevel(logging.INFO)
        logger.info('debug messages disabled')


async def thermostat_cycle(timetable, heating, thermometer, lock, loop):
    """The main cycle of temperature checking.
    
    Periodically checks the temperature and switch on/off the heating
    accordingly.
    
    If a known error is catched somewhere, a message is printed to syslog and
    the daemon is leaved running even if a manual operation of the user is
    required to fix the contidion. In case of unknown error, a critical message
    is printed and the daemon is closed.
    """
    
    global enabled, main_return_code
    logger.info('daemon started ({})', PROGRAM_VERSION)
    
    try:
        try:
            logger.info('the heating is currently {}', (heating.is_on() and 'ON' or 'OFF'))
            
        except Exception as e:
            # We report the error as a severe error but we do nothing because
            # it can be a transient error, if it isn't transient, the error
            # will appears again in the hereafter "while" cycle and it will
            # be managed there.
            logger.error('cannot query the heating to retrieve current status: {}', e)
        
        # The following variable is needed to print info messages only
        # when no timeout has occurred, that means that someone has changed
        # some settings.
        cycle_timeout = False
        
        # the real cycle of temperature checking
        while enabled:
            try:
                async with lock:
                    try:
                        should_be_on = timetable.should_the_heating_be_on(
                                            thermometer.temperature,
                                            heating.status)
                        
                        _msg = ('status: {!r}, '
                                'current: {:.1f}, '
                                'target: {:.1f}').format(
                                    should_be_on.status.status,
                                    should_be_on.status.current_temperature,
                                    float(should_be_on.status.target_temperature or 'NaN'))
                        
                        if should_be_on == should_be_on.status.heating_status:
                            # The heating is already as it should be, so an
                            # info message is printed only if some settings
                            # have been changed from outside (the timeout has
                            # not occurred).
                            log = (logger.info if not cycle_timeout else logger.debug)
                            log('heating already {} ({})',
                                ('ON' if should_be_on.status.heating_status else 'OFF'),
                                _msg)
                        
                        else:  # the heating must be switched
                            if should_be_on:
                                heating.switch_on()
                            else:
                                heating.switch_off()
                            
                            logger.info('heating switched {} ({})',
                                        ('ON' if should_be_on else 'OFF'),
                                        _msg)
                    
                    except ValidationError as jsve:
                        # The internal settings must be valid otherwise an error
                        # should have already been catched in other sections of
                        # the program, even if new settings are set from
                        # socket connection. We print a critical message but
                        # we leave the daemon running. Manual intervention of
                        # the user is required to fix this condition.
                        newstatus = ThermodStatus(time.time(), error='Invalid element in timetable file')
                        logger.critical('invalid element {} in timetable file: {}', list(jsve.path), jsve)
                        #shutdown(exitcode=common.RET_CODE_RUN_INVALID_STATE)
                    
                    except JsonValueError as jve:
                        # A strange value has been set somewhere and the daemon
                        # didn't catch the appropriate exception. We print a
                        # critical message but we leave the daemon running.
                        # Manual intervention of the user is required to fix
                        # this condition.
                        newstatus = ThermodStatus(time.time(), error='Invalid value in running daemon')
                        logger.critical(jve)
                        #shutdown(exitcode=common.RET_CODE_RUN_INVALID_VALUE)
                    
                    except ScriptError as se:
                        # One of the external scripts reported an error, we
                        # print it as a severe error but we leave the daemon
                        # running even if probably it is not fully functional.
                        newstatus = ThermodStatus(time.time(), error='Error in script {}'.format(se.script))
                        logger.error('the script `{}` reported the following '
                                     'error: {}', se.script, se)
                    
                    except ThermometerError as te:
                        newstatus = ThermodStatus(time.time(), error='Error from thermometer')
                        logger.error('error from thermometer: {} ({})', te,
                                     (te.suberror if te.suberror else 'no other information'))
                    
                    except HeatingError as he:
                        newstatus = ThermodStatus(time.time(), error='Error from heating')
                        logger.error('error from heating: {} ({})', he,
                                     (he.suberror if he.suberror else 'no other information'))
                    
                    except asyncio.CancelledError:
                        newstatus = ThermodStatus(time.time(), error='Shutting down Thermod')
                        raise
                    
                    except Exception:
                        # There is an unknown error. We create an error-status
                        # for monitors and we re-raise the exception.
                        newstatus = ThermodStatus(time.time(), error='Unknown Error')
                        raise
                    
                    else:
                        newstatus = should_be_on.status._replace(heating_status=heating.status)
                    
                    finally:  # we update all connected monitors
                        loop.create_task(socket.update_monitors(newstatus))
                    
                    # A shutdown may have been requested before reaching
                    # this point and in such situation we don't have to
                    # wait for a notify, simply go on and exit the cycle.
                    if enabled:
                        # We suspend the process and wait to check again the
                        # temperature. The wait is wrapped in a timeout to force
                        # a check at least any `settings.interval` seconds.
                        try:
                            async with timeout(settings.interval, loop=loop):
                                await lock.wait()
                        
                        except asyncio.TimeoutError:
                            cycle_timeout = True
                        
                        else:
                            cycle_timeout = False
            
            
            except asyncio.CancelledError:
                raise
            
            except Exception as e:
                # An unknown error occurred somewhere, a critical message is
                # printed and the daemon will be closed.
                logger.critical('unknown error occurred: {}', e, exc_info=True)
                shutdown(common.RET_CODE_RUN_OTHER_ERR)
    
    except asyncio.CancelledError:
        logger.debug('main cycle cancelled')
        raise
    
    logger.debug('main cycle stopped')


# main
logger.debug('starting daemon')

main_loop.add_signal_handler(signal.SIGINT, shutdown)
main_loop.add_signal_handler(signal.SIGTERM, shutdown)
main_loop.add_signal_handler(signal.SIGHUP, reload_timetable)
main_loop.add_signal_handler(signal.SIGUSR1, toggle_debug_messages)

# start control socket
try:
    socket.start()

except OSError as oe:
    # probably the socket address is already in use
    logger.critical('cannot start control socket: {}', oe)
    main_return_code = common.RET_CODE_SOCKET_PORT_ERR

except Exception as e:
    logger.critical('cannot start control socket: {}', e, exc_info=True)
    main_return_code = common.RET_CODE_SOCKET_START_ERR

except KeyboardInterrupt:
    main_return_code = common.RET_CODE_KEYB_INTERRUPT

else:
    main_return_code = common.RET_CODE_OK

finally:
    if main_return_code != common.RET_CODE_OK:
        logger.info('closing daemon with return code {}', main_return_code)
        exit(main_return_code)

# run the main loop
try:
    logger.debug('starting main cycle')
    main_loop.run_until_complete(thermostat_cycle(timetable, heating, thermometer, masterlock, main_loop))

# TODO verificare quali altre eccezioni potrebbero verificarsi
finally:
    logger.debug('finalizing daemon shutdown')
    
    # stop the socket
    try:
        socket.stop()
    
    except Exception as e:
        logger.error('unexpected error stopping control socket: {}', e, exc_info=True)
        
        # We set a new exit code only if this is the first error
        # otherwise we leave the original error exit code.
        if main_return_code == common.RET_CODE_OK:
            main_return_code = common.RET_CODE_SOCKET_STOP_ERR
    
    except KeyboardInterrupt:
        # We are already shutting down, no other operations required
        pass
    
    # switch off the heating
    try:
        if heating.is_on():
            heating.switch_off()
            logger.info('heating switched OFF')
    
    except ScriptError as se:
        logger.warning('the script `{}` reported the following error '
                       'while shutting down the daemon: {}', se.script, se)
        
        # We set a new exit code only if this is the first error
        # otherwise we leave the original error exit code.
        if main_return_code == common.RET_CODE_OK:
            main_return_code = common.RET_CODE_SHUTDOWN_SWITCHOFF_ERR
    
    except HeatingError as he:
        logger.warning('error from heating while shutting down the '
                       'daemon: {} ({})', he, (he.suberror if he.suberror else 'no other information'))
        
        # We set a new exit code only if this is the first error
        # otherwise we leave the original error exit code.
        if main_return_code == common.RET_CODE_OK:
            main_return_code = common.RET_CODE_SHUTDOWN_SWITCHOFF_ERR
    
    except Exception as e:
        logger.error('error switching off the heating during '
                     'daemon shutdown: {}', e, exc_info=True)
        
        # We set a new exit code only if this is the first error
        # otherwise we leave the original error exit code.
        if main_return_code == common.RET_CODE_OK:
            main_return_code = common.RET_CODE_SHUTDOWN_OTHER_ERR
    
    except KeyboardInterrupt:
        # We are already shutting down, no other operations required
        pass
    
    logger.info('daemon stopped')
    
    # close the main loop
    logger.debug('closing main event loop')
    main_loop.close()


# closing daemon
if main_return_code != common.RET_CODE_OK:
    logger.info('closing daemon with return code {}', main_return_code)

exit(main_return_code)

# vim: fileencoding=utf-8 tabstop=4 shiftwidth=4 expandtab
